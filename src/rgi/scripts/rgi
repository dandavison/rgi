#!/usr/bin/env python3
import os
import shlex
import subprocess
import sys
from pathlib import Path

HISTORY_FILE = Path.home() / ".rgi_history"


def main() -> None:
    script_dir = str(Path(__file__).resolve().parent)
    os.environ["PATH"] = f"{script_dir}:{os.environ.get('PATH', '')}"

    pattern, paths, rg_opts = parse_arguments(sys.argv[1:])

    ripgrep_config_path = os.environ.get("RIPGREP_CONFIG_PATH", "")
    config_args = parse_ripgrep_config(ripgrep_config_path)

    implicit_opts = "--json"
    delta = "delta --grep-output-type classic"

    fzf_cmd = build_command_mode_fzf(
        pattern, paths, rg_opts, config_args, delta, ripgrep_config_path, implicit_opts
    )

    fzf_cmd_str = " ".join(shlex.quote(arg) for arg in fzf_cmd)
    sys.exit(subprocess.call(f'echo "" | {fzf_cmd_str}', shell=True, executable="/bin/bash"))


def parse_arguments(argv: list[str]) -> tuple[str, list[str], str]:
    pattern = ""
    paths = []
    rg_opts = ""

    i = 0
    while i < len(argv):
        if argv[i].startswith("-"):
            opt = argv[i]
            rg_opts += f" {opt}"
            i += 1
            if opt in ["-g", "--glob", "-t", "--type", "-e", "--regexp"] and i < len(argv):
                rg_opts += f" '{argv[i]}'"
                i += 1
        else:
            break

    if i < len(argv):
        pattern = argv[i]
        i += 1
    while i < len(argv):
        paths.append(argv[i])
        i += 1

    return pattern, paths, rg_opts.strip()


def parse_ripgrep_config(config_path: str) -> str:
    if not config_path or not os.path.isfile(config_path):
        return ""

    config_args = ""
    with open(config_path, "r") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            if not line.startswith("-"):
                line = f"'{line}'"
            config_args += f" {line}"

    return config_args.strip()


def fzf_base() -> list[str]:
    return [
        "fzf",
        "--height",
        "100%",
        "--layout",
        "reverse",
        "--info",
        "hidden",
        "--prompt",
        " ",
        "--ansi",
        "--bind",
        "ctrl-k:kill-line",
        "--bind",
        "alt-right:forward-word",
        "--bind",
        "alt-left:backward-word",
        "--preview-window",
        "up,70%",
    ]


def build_command_mode_fzf(
    pattern: str,
    paths: list[str],
    rg_opts: str,
    config_args: str,
    delta: str,
    ripgrep_config_path: str,
    implicit_opts: str,
) -> list[str]:
    # rgi command format: rg <options+pattern> PATH
    # Path is always explicit (defaults to .) and always last
    paths_str = " ".join(paths) if paths else "."
    quoted_pattern = shlex.quote(pattern) if pattern else ""
    full_command = " ".join(f"rg {rg_opts} {quoted_pattern} {paths_str}".split())
    # Add space before path when no pattern, so cursor lands between "rg " and " ."
    if not pattern and not paths:
        full_command = "rg  ."  # Two spaces: "rg | ." with cursor in middle

    # Path prefix matching: last word is always the path
    # Expand with glob if it doesn't exist as-is
    # Trailing space disables expansion (escape hatch for literal paths)
    glob_expand = """
        if [[ ! "$cmd" =~ [[:space:]]$ ]]; then
            last="${cmd##* }";
            if [[ "$last" != -* && ! -e "$last" && -n "$last" ]]; then
                shopt -s nullglob;
                matches=( ${last}* );
                shopt -u nullglob;
                if [[ ${#matches[@]} -gt 0 ]]; then
                    cmd="${cmd% *} ${matches[*]}";
                fi;
            fi;
        fi;
    """.replace("\n", " ").strip()

    reload_cmd = f"""
        cmd={{q}};
        {glob_expand}
        if [[ "$cmd" =~ ^rg ]]; then
            cmd="${{cmd#rg}}";
            cmd="rg {config_args} {implicit_opts}$cmd";
        fi;
        RIPGREP_CONFIG_PATH= eval "$cmd" 2>/dev/null | {delta}
    """.replace("\n", " ").strip()

    # Save to history before opening editor (fzf's --history only saves on exit, but rgi persists)
    history_file = str(HISTORY_FILE)
    save_history = f'[[ "$(tail -1 {history_file} 2>/dev/null)" != {{q}} ]] && echo {{q}} >> {history_file};'
    enter_execute = f"{save_history} open-in-editor {{1}} {{2}}"

    cmd = fzf_base() + [
        "-d:",
        "--query",
        full_command,
        "--phony",
        "--header",
        config_args if config_args else "",
        "--preview",
        "[[ -n {1} ]] && rgi-preview {1} {2}",
        "--history",
        str(HISTORY_FILE),
        "--bind",
        f"start:reload:{reload_cmd}",
        # When using default path '.', position cursor before it so user can type pattern
        # Use result event (fires after filtering) and unbind to run only once
        "--bind",
        "result:backward-char+backward-char+unbind(result)" if not paths else "result:ignore",
        "--bind",
        f"change:reload:{reload_cmd}",
        "--bind",
        f"enter:execute:{enter_execute}",
        "--bind",
        "alt-up:prev-history",
        "--bind",
        "alt-down:next-history",
        "--bind",
        "ctrl-p:up",
        "--bind",
        "ctrl-n:down",
    ]

    return cmd


if __name__ == "__main__":
    main()
