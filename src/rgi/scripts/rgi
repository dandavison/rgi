#!/usr/bin/env python3
from __future__ import annotations

import os
import shlex
import subprocess
import sys
from pathlib import Path
from typing import List, Tuple


def main() -> None:
    """Main entry point for rgi."""
    # Debug logging (disabled for now)
    # with open("/tmp/rgi-debug.log", "a") as f:
    #     f.write(f"rgi started with args: {sys.argv}\n")

    # Get absolute path to this script
    SCRIPT_PATH: str = str(Path(__file__).resolve())

    # Get directory containing this script
    SCRIPT_DIR: str = str(Path(SCRIPT_PATH).parent)

    # Add script directory to PATH so rgi-preview can be found
    os.environ["PATH"] = f"{SCRIPT_DIR}:{os.environ.get('PATH', '')}"

    # Parse command line arguments
    mode: str
    pattern: str
    paths: List[str]
    rg_opts: str
    mode, pattern, paths, rg_opts = parse_arguments(sys.argv[1:])

    # Parse ripgrep config file
    RIPGREP_CONFIG_PATH: str = os.environ.get("RIPGREP_CONFIG_PATH", "")
    config_args: str = parse_ripgrep_config(RIPGREP_CONFIG_PATH)

    # Implicit options that are always applied but never shown
    IMPLICIT_OPTS: str = "--json"

    # Commands
    # Include config args explicitly (not via RIPGREP_CONFIG_PATH to avoid double application)
    config_part: str = f" {config_args}" if config_args else ""
    RG: str = f"rg{config_part}{rg_opts} {IMPLICIT_OPTS}"
    DELTA: str = "delta --grep-output-type classic"

    # Build fzf command based on mode
    fzf_cmd: List[str]
    if mode == "command":
        fzf_cmd = build_command_mode_fzf(
            pattern,
            paths,
            rg_opts,
            config_args,
            RG,
            DELTA,
            RIPGREP_CONFIG_PATH,
            IMPLICIT_OPTS,
        )
    elif mode == "pattern":
        fzf_cmd = build_pattern_mode_fzf(
            pattern, paths, rg_opts, config_args, RG, DELTA, RIPGREP_CONFIG_PATH
        )
    else:
        sys.exit(1)

    # Run fzf with empty input
    # Need to pipe echo "" | fzf, so we'll use subprocess but with shell=True
    # to preserve the exact bash behavior
    fzf_cmd_str: str = " ".join(shlex.quote(arg) for arg in fzf_cmd)
    full_cmd: str = f'echo "" | {fzf_cmd_str}'
    sys.exit(subprocess.call(full_cmd, shell=True))


# ============================================================================
# Helper Functions
# ============================================================================


def parse_arguments(argv: List[str]) -> Tuple[str, str, List[str], str]:
    """Parse command line arguments for rgi.

    Args:
        argv: Command line arguments (excluding program name)

    Returns:
        tuple: (mode, pattern, paths, rg_opts)
            - mode: "command" or "pattern"
            - pattern: search pattern string
            - paths: list of paths to search
            - rg_opts: ripgrep options string
    """
    pattern: str = ""
    paths: List[str] = []
    rg_opts: str = ""
    mode: str = "command"  # default mode

    i: int = 0
    while i < len(argv):
        if argv[i] == "--rgi-command-mode":
            mode = "command"
            i += 1
        elif argv[i] == "--rgi-pattern-mode":
            mode = "pattern"
            i += 1
        elif argv[i].startswith("-"):
            opt = argv[i]
            rg_opts += f" {opt}"
            i += 1
            # Handle options that take arguments
            if opt in ["-g", "--glob", "-t", "--type", "-e", "--regexp"]:
                if i < len(argv):
                    rg_opts += f" '{argv[i]}'"
                    i += 1
        else:
            break

    # Pattern and paths
    if i < len(argv):
        pattern = argv[i]
        i += 1
    while i < len(argv):
        paths.append(argv[i])
        i += 1

    return mode, pattern, paths, rg_opts


def parse_ripgrep_config(config_path: str) -> str:
    """Parse ripgrep configuration file.

    Args:
        config_path: Path to ripgrep config file from RIPGREP_CONFIG_PATH env var

    Returns:
        str: Space-separated string of config arguments, or empty string
    """
    if not config_path or not os.path.isfile(config_path):
        return ""

    config_args: str = ""
    with open(config_path, "r") as f:
        for line in f:
            # Trim leading/trailing whitespace
            line = line.strip()
            # Skip comments and empty lines
            if not line or line.startswith("#"):
                continue
            # If line doesn't start with -, wrap it in single quotes
            # (config files don't need quotes, but shell commands do)
            if not line.startswith("-"):
                line = f"'{line}'"
            # Add each arg - they need to be properly spaced
            if config_args:
                config_args += f" {line}"
            else:
                config_args = line

    return config_args


def fzf_base() -> List[str]:
    """Build base fzf options common to all modes.

    Returns:
        List of fzf base arguments
    """
    return [
        "fzf",
        "--layout",
        "reverse",
        "--info",
        "hidden",
        "--prompt",
        " ",
        "--color",
        "light",
        "--ansi",
        "--bind",
        "ctrl-k:kill-line",
        "--bind",
        "alt-right:forward-word",
        "--bind",
        "alt-left:backward-word",
        "--preview-window",
        "up,70%",
    ]


def _build_command_mode_reload(
    config_args: str, implicit_opts: str, delta_cmd: str
) -> str:
    """Build the reload command for command mode in a clean, documented way.

    This command handles user input from fzf's query field:
    1. Captures the query (available as {q})
    2. If it starts with 'rg', strips that prefix
    3. Rebuilds the command with proper config and options
    4. Executes with RIPGREP_CONFIG_PATH cleared to avoid double-application
    5. Pipes through delta for formatting

    Args:
        config_args: Config arguments to insert (e.g., " --max-columns=150")
        implicit_opts: Options always applied but not shown (e.g., "--json")
        delta_cmd: The delta command for output formatting

    Returns:
        A single-line bash command suitable for fzf's --bind option
    """
    # Build the command components
    capture_query = "cmd={q}"

    # Process commands starting with 'rg'
    config_insert = f" {config_args}" if config_args else ""
    process_rg_prefix = (
        'if [[ "$cmd" =~ ^rg ]]; then '
        'cmd="${cmd#rg}"; '  # Remove 'rg' prefix
        f'cmd="rg{config_insert} {implicit_opts}$cmd"; '  # Rebuild with our options
        "fi"
    )

    # Execute with environment control and pipe through delta
    execute_and_format = f'RIPGREP_CONFIG_PATH= eval "$cmd" 2>/dev/null | {delta_cmd}'

    # Combine all parts
    return f"{capture_query}; {process_rg_prefix}; {execute_and_format}"


def build_command_mode_fzf(
    pattern: str,
    paths: List[str],
    rg_opts: str,
    config_args: str,
    RG: str,
    DELTA: str,
    RIPGREP_CONFIG_PATH: str,
    IMPLICIT_OPTS: str,
) -> List[str]:
    """Build fzf command for command mode.

    Args:
        pattern: Search pattern
        paths: List of paths to search
        rg_opts: Ripgrep options
        config_args: Arguments from config file
        RG: Full ripgrep command with config and implicit opts
        DELTA: Delta command for formatting
        RIPGREP_CONFIG_PATH: Path to ripgrep config file
        IMPLICIT_OPTS: Implicit options like --json

    Returns:
        list: Complete fzf command as list of arguments
    """
    # Command mode - show command WITHOUT config args in query (they're shown in header)
    # This prevents duplication when switching modes
    paths_str: str = " ".join(paths)
    # Quote pattern for shell safety (shlex.quote handles spaces and special chars)
    quoted_pattern: str = shlex.quote(pattern) if pattern else ""
    full_command: str = f"rg{rg_opts} {quoted_pattern} {paths_str}"

    # Show effective command including config in header
    header: str
    if config_args:
        header = f"Config applied: {config_args}"
    else:
        header = ""

    # Build the reload command in a clean, documented way
    reload_cmd: str = _build_command_mode_reload(config_args, IMPLICIT_OPTS, DELTA)

    # Build the tab:execute command for mode switching
    tab_execute: str = _build_tab_execute(
        mode="pattern", ripgrep_config_path=RIPGREP_CONFIG_PATH, query="{q}"
    )

    return fzf_base() + [
        "-d:",
        "--query",
        f"{full_command} ",
        "--phony",
        "--bind",
        f"start:reload:{reload_cmd}",
        "--bind",
        "start:backward-delete-char",
        "--bind",
        f"change:reload:{reload_cmd}",
        "--bind",
        f"tab:execute:{tab_execute}",
        "--bind",
        "enter:execute:open-in-editor {1} {2}",
        "--header",
        header,
        "--preview",
        "[[ -n {1} ]] && rgi-preview {1} {2}",
    ]


def _build_pattern_mode_reload(
    rg_cmd: str, pattern: str, paths: str, delta_cmd: str, is_start: bool = False
) -> str:
    """Build the reload command for pattern mode.

    This is simpler than command mode - just run rg with the pattern.

    Args:
        rg_cmd: The full rg command with options
        pattern: The search pattern (actual pattern for start, {q} for dynamic)
        paths: Space-separated list of paths to search
        delta_cmd: The delta command for output formatting
        is_start: True for start:reload (uses initial pattern), False for change:reload

    Returns:
        A single-line bash command suitable for fzf's --bind option
    """
    # Clear RIPGREP_CONFIG_PATH to avoid double-application of config
    # Run rg with pattern and paths, suppress errors, pipe through delta
    return f"RIPGREP_CONFIG_PATH= {rg_cmd} {pattern} {paths} 2>/dev/null | {delta_cmd}"


def _build_tab_execute(
    mode: str, ripgrep_config_path: str, query: str = "{q}", **kwargs
) -> str:
    """Build the tab:execute command for mode switching.

    Args:
        mode: Target mode ('pattern' or 'command')
        ripgrep_config_path: Path to ripgrep config file (if any)
        query: The current query (usually {q})
        **kwargs: Additional arguments depending on mode
            - For 'command' mode: rg_opts, paths_str

    Returns:
        A command string for the tab:execute binding
    """
    # Set environment variable if we have a config path
    env_prefix = (
        f'RIPGREP_CONFIG_PATH="{ripgrep_config_path}"' if ripgrep_config_path else ""
    )

    if mode == "pattern":
        # Switching to pattern mode (from command mode)
        return f"{env_prefix} rgi-switch-mode pattern {query}"
    else:
        # Switching to command mode (from pattern mode)
        rg_opts = kwargs.get("rg_opts", "")
        paths_str = kwargs.get("paths_str", "")
        return f"{env_prefix} rgi-switch-mode command {query} {rg_opts} {paths_str} "


def build_pattern_mode_fzf(
    pattern: str,
    paths: List[str],
    rg_opts: str,
    config_args: str,
    RG: str,
    DELTA: str,
    RIPGREP_CONFIG_PATH: str,
) -> List[str]:
    """Build fzf command for pattern mode.

    Args:
        pattern: Search pattern
        paths: List of paths to search
        rg_opts: Ripgrep options
        config_args: Arguments from config file
        RG: Full ripgrep command with config and implicit opts
        DELTA: Delta command for formatting
        RIPGREP_CONFIG_PATH: Path to ripgrep config file

    Returns:
        list: Complete fzf command as list of arguments
    """
    # Pattern mode - the query is just the search pattern
    paths_str: str = " ".join(paths)

    # Quote pattern for display in fzf query (shlex.quote handles spaces and special chars)
    query_pattern: str = shlex.quote(pattern) if pattern else ""

    # Build the bind commands in a clean, documented way
    # For start:reload, use the initial pattern (properly quoted for shell safety)
    start_reload: str = _build_pattern_mode_reload(
        rg_cmd=RG,
        pattern=shlex.quote(pattern) if pattern else "",
        paths=paths_str,
        delta_cmd=DELTA,
        is_start=True,
    )

    # For change:reload, use the dynamic query from fzf
    change_reload: str = _build_pattern_mode_reload(
        rg_cmd=RG, pattern="{q}", paths=paths_str, delta_cmd=DELTA, is_start=False
    )

    # Build the tab:execute command for mode switching
    tab_execute: str = _build_tab_execute(
        mode="command",
        ripgrep_config_path=RIPGREP_CONFIG_PATH,
        query="{q}",
        rg_opts=rg_opts,
        paths_str=paths_str,
    )

    header: str = f"rg{config_args if config_args else ''}{rg_opts} {{q}} {paths_str}"

    return fzf_base() + [
        "-d:",
        "--query",
        f"{query_pattern} ",
        "--phony",
        "--bind",
        f"start:reload:{start_reload}",
        "--bind",
        "start:backward-delete-char",
        "--bind",
        f"change:reload:{change_reload}",
        "--bind",
        f"tab:execute:{tab_execute}",
        "--bind",
        "enter:execute:open-in-editor {1} {2}",
        "--header",
        header,
        "--preview",
        "[[ -n {1} ]] && rgi-preview {1} {2}",
    ]


if __name__ == "__main__":
    main()
