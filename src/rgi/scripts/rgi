#!/usr/bin/env python3
import os
import shlex
import subprocess
import sys
from pathlib import Path

# Debug logging (disabled for now)
# with open("/tmp/rgi-debug.log", "a") as f:
#     f.write(f"rgi started with args: {sys.argv}\n")

# Get absolute path to this script
SCRIPT_PATH = str(Path(__file__).resolve())

# Get directory containing this script
SCRIPT_DIR = str(Path(SCRIPT_PATH).parent)

# Add script directory to PATH so rgi-preview can be found
os.environ["PATH"] = f"{SCRIPT_DIR}:{os.environ.get('PATH', '')}"

# Parse arguments
pattern = ""
paths = []
rg_opts = ""
MODE = "command"

# Single pass through arguments
argv = sys.argv[1:]  # Skip script name
i = 0
while i < len(argv):
    if argv[i] == "--rgi-command-mode":
        MODE = "command"
        i += 1
    elif argv[i] == "--rgi-pattern-mode":
        MODE = "pattern"
        i += 1
    elif argv[i].startswith("-"):
        opt = argv[i]
        rg_opts += f" {opt}"
        i += 1
        if opt in ["-g", "--glob", "-t", "--type", "-e", "--regexp"]:
            if i < len(argv):
                rg_opts += f" '{argv[i]}'"
                i += 1
    else:
        break

# Pattern and paths
if i < len(argv):
    pattern = argv[i]
    i += 1
while i < len(argv):
    paths.append(argv[i])
    i += 1
if len(paths) == 0:
    paths = ["."]


# Helper function to quote pattern if it contains spaces
def quote_if_spaces(s):
    """Quote a string if it contains spaces, for use in shell commands and fzf queries"""
    if " " in s:
        return f"'{s}'"
    return s


# Parse ripgrep config file if RIPGREP_CONFIG_PATH is set
# We'll include these args explicitly rather than relying on ripgrep to read them
config_args = ""
RIPGREP_CONFIG_PATH = os.environ.get("RIPGREP_CONFIG_PATH", "")
if RIPGREP_CONFIG_PATH and os.path.isfile(RIPGREP_CONFIG_PATH):
    # Parse the config file - each non-comment line is an argument
    with open(RIPGREP_CONFIG_PATH, "r") as f:
        for line in f:
            # Trim leading/trailing whitespace
            line = line.strip()
            # Skip comments and empty lines
            if not line or line.startswith("#"):
                continue
            # If line doesn't start with -, wrap it in single quotes
            # (config files don't need quotes, but shell commands do)
            if not line.startswith("-"):
                line = f"'{line}'"
            # Add each arg - they need to be properly spaced
            if config_args:
                config_args += f" {line}"
            else:
                config_args = line

# Implicit options that are always applied but never shown
IMPLICIT_OPTS = "--json"

# Commands
# Include config args explicitly (not via RIPGREP_CONFIG_PATH to avoid double application)
config_part = f" {config_args}" if config_args else ""
RG = f"rg{config_part}{rg_opts} {IMPLICIT_OPTS}"
DELTA = "delta --grep-output-type classic"


# Build fzf base options
def fzf_base():
    return [
        "fzf",
        "--layout",
        "reverse",
        "--info",
        "hidden",
        "--prompt",
        " ",
        "--color",
        "light",
        "--ansi",
        "--bind",
        "ctrl-k:kill-line",
        "--bind",
        "alt-right:forward-word",
        "--bind",
        "alt-left:backward-word",
        "--preview-window",
        "up,70%",
    ]


# Use --phony with start:reload to show initial results
# Hack: to trigger display we append a space and then delete it on start
if MODE == "command":
    # Command mode - show command WITHOUT config args in query (they're shown in header)
    # This prevents duplication when switching modes
    paths_str = " ".join(paths)
    # Quote pattern if it contains spaces
    quoted_pattern = quote_if_spaces(pattern) if pattern else ""
    full_command = f"rg{rg_opts} {quoted_pattern} {paths_str}"

    # Show effective command including config in header
    if config_args:
        header = f"Config applied: {config_args}"
    else:
        header = ""

    # Build the complex bind strings
    config_insert = f" {config_args}" if config_args else ""

    # start:reload and change:reload bindings
    reload_cmd = f'cmd={{q}}; if [[ "$cmd" =~ ^rg ]]; then cmd="${{cmd#rg}}"; cmd="rg{config_insert} {IMPLICIT_OPTS}$cmd"; fi; RIPGREP_CONFIG_PATH= eval "$cmd" 2>/dev/null | {DELTA}'

    # tab:execute binding
    ripgrep_env = (
        f'RIPGREP_CONFIG_PATH="{RIPGREP_CONFIG_PATH}"' if RIPGREP_CONFIG_PATH else ""
    )
    tab_execute = f"{ripgrep_env} rgi-switch-mode pattern {{q}}"

    fzf_cmd = fzf_base() + [
        "-d:",
        "--query",
        f"{full_command} ",
        "--phony",
        "--bind",
        f"start:reload:{reload_cmd}",
        "--bind",
        "start:backward-delete-char",
        "--bind",
        f"change:reload:{reload_cmd}",
        "--bind",
        f"tab:execute:{tab_execute}",
        "--bind",
        "enter:execute:open-in-editor {1} {2}",
        "--header",
        header,
        "--preview",
        "[[ -n {1} ]] && rgi-preview {1} {2}",
    ]

elif MODE == "pattern":
    # Pattern mode - the query is just the search pattern
    paths_str = " ".join(paths)

    # Quote pattern for display in fzf query if it contains spaces
    query_pattern = quote_if_spaces(pattern) if pattern else ""

    # Build the bind strings
    # For start_reload, always quote the pattern for shell safety
    start_reload = f"RIPGREP_CONFIG_PATH= {RG} {shlex.quote(pattern) if pattern else ''} {paths_str} 2>/dev/null | {DELTA}"
    change_reload = f"RIPGREP_CONFIG_PATH= {RG} {{q}} {paths_str} 2>/dev/null | {DELTA}"

    ripgrep_env = (
        f'RIPGREP_CONFIG_PATH="{RIPGREP_CONFIG_PATH}"' if RIPGREP_CONFIG_PATH else ""
    )
    tab_execute = f"{ripgrep_env} rgi-switch-mode command {{q}} {rg_opts} {paths_str} "

    header = f"rg{config_args if config_args else ''}{rg_opts} {{q}} {paths_str}"

    fzf_cmd = fzf_base() + [
        "-d:",
        "--query",
        f"{query_pattern} ",
        "--phony",
        "--bind",
        f"start:reload:{start_reload}",
        "--bind",
        "start:backward-delete-char",
        "--bind",
        f"change:reload:{change_reload}",
        "--bind",
        f"tab:execute:{tab_execute}",
        "--bind",
        "enter:execute:open-in-editor {1} {2}",
        "--header",
        header,
        "--preview",
        "[[ -n {1} ]] && rgi-preview {1} {2}",
    ]
else:
    sys.exit(1)

# Run fzf with empty input
# Need to pipe echo "" | fzf, so we'll use subprocess but with shell=True
# to preserve the exact bash behavior
fzf_cmd_str = " ".join(shlex.quote(arg) for arg in fzf_cmd)
full_cmd = f'echo "" | {fzf_cmd_str}'
sys.exit(subprocess.call(full_cmd, shell=True))
