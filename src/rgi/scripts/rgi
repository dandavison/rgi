#!/usr/bin/env python3
import atexit
import os
import shlex
import subprocess
import sys
from pathlib import Path

HISTORY_FILE = Path.home() / ".rgi_history"


def main() -> None:
    script_dir = str(Path(__file__).resolve().parent)
    os.environ["PATH"] = f"{script_dir}:{os.environ.get('PATH', '')}"

    pattern, paths, rg_opts = parse_arguments(sys.argv[1:])

    ripgrep_config_path = os.environ.get("RIPGREP_CONFIG_PATH", "")
    config_args = parse_ripgrep_config(ripgrep_config_path)

    implicit_opts = "--json --sort=path"
    delta = "delta --grep-output-type classic"

    # Create state file for toggle feature
    # State tracks: mode (pinned/inline) and pinned options
    state_file = Path(f"/tmp/rgi-pinned-{os.getpid()}.state")
    initial_mode = "pinned" if config_args else "inline"
    state_file.write_text(f"{initial_mode}|{config_args}")
    os.environ["RGI_STATE_FILE"] = str(state_file)

    # Clean up state file on exit
    atexit.register(lambda: state_file.unlink(missing_ok=True))

    fzf_cmd_str = " ".join(
        shlex.quote(arg)
        for arg in build_fzf_command(pattern, paths, rg_opts, config_args, delta, implicit_opts)
    )
    sys.exit(subprocess.call(f'echo "" | {fzf_cmd_str}', shell=True, executable="/bin/bash"))


def parse_arguments(argv: list[str]) -> tuple[str, list[str], str]:
    pattern = ""
    paths = []
    rg_opts = ""

    i = 0
    while i < len(argv):
        if argv[i].startswith("-"):
            opt = argv[i]
            rg_opts += f" {opt}"
            i += 1
            if opt in ["-g", "--glob", "-t", "--type", "-e", "--regexp"] and i < len(argv):
                rg_opts += f" '{argv[i]}'"
                i += 1
        else:
            break

    if i < len(argv):
        pattern = argv[i]
        i += 1
    while i < len(argv):
        paths.append(argv[i])
        i += 1

    return pattern, paths, rg_opts.strip()


def parse_ripgrep_config(config_path: str) -> str:
    if not config_path or not os.path.isfile(config_path):
        return ""

    config_args = ""
    with open(config_path, "r") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            if not line.startswith("-"):
                line = f"'{line}'"
            config_args += f" {line}"

    return config_args.strip()


def fzf_base() -> list[str]:
    return [
        "fzf",
        # Force bash for reload commands - zsh doesn't support all bash features we use
        "--with-shell",
        "bash -c",
        "--height",
        "100%",
        "--layout",
        "reverse",
        "--info",
        "hidden",
        "--prompt",
        " ",
        "--ansi",
        "--bind",
        "ctrl-k:kill-line",
        "--bind",
        "alt-right:forward-word",
        "--bind",
        "alt-left:backward-word",
        "--no-border",
        "--preview-window",
        "up,70%,~3",
    ]


def build_fzf_command(
    pattern: str,
    paths: list[str],
    rg_opts: str,
    config_args: str,
    delta: str,
    implicit_opts: str,
) -> list[str]:
    # rgi command format: rg <options+pattern> PATH
    # Path is always explicit (defaults to .) and always last
    paths_str = " ".join(paths) if paths else "."
    quoted_pattern = shlex.quote(pattern) if pattern else ""

    # Startup mode depends on whether we have config args:
    # - Pinned mode (config_args exist): footer shows config, query is "rg [opts] pattern paths"
    # - Inline mode (no config_args): footer empty, all opts in query
    if config_args:
        # Pinned mode: config in footer, user opts + pattern + paths in query
        full_command = " ".join(f"rg {rg_opts} {quoted_pattern} {paths_str}".split())
        initial_footer = config_args
    else:
        # Inline mode: everything in query, no footer
        full_command = " ".join(f"rg {rg_opts} {quoted_pattern} {paths_str}".split())
        initial_footer = ""

    # Add space before path when no pattern, so cursor lands between "rg " and " ."
    if not pattern and not paths and not rg_opts:
        full_command = "rg  ."  # Two spaces: "rg | ." with cursor in middle

    # Path prefix matching: last word is always the path
    # Expand with glob if it doesn't exist as-is
    # Trailing space disables expansion (escape hatch for literal paths)
    # IMPORTANT: Filter matches against exclusion patterns from BOTH pinned_opts AND cmd
    # because rg's -g exclusions only apply to discovered files, not explicit paths
    # In pinned mode: exclusions are in pinned_opts (header)
    # In inline mode: exclusions are in cmd itself (query line)
    # NOTE: No bash comments in this string - it becomes a one-liner where # breaks things
    glob_expand = """
        if [[ ! "$cmd" =~ [[:space:]]$ ]]; then
            last="${cmd##* }";
            if [[ "$last" != -* && ! -e "$last" && -n "$last" ]]; then
                shopt -s nullglob;
                matches=( ${last}* );
                shopt -u nullglob;
                if [[ ${#matches[@]} -gt 0 ]]; then
                    all_opts="$pinned_opts $cmd";
                    if echo "$all_opts" | grep -qE "'![^']*'"; then
                        filtered=();
                        for m in "${matches[@]}"; do
                            excluded=false;
                            while IFS= read -r pattern; do
                                if [[ -n "$pattern" && "$(basename "$m")" == $pattern ]]; then
                                    excluded=true;
                                    break;
                                fi;
                            done < <(echo "$all_opts" | grep -oE "'![^']*'" | sed "s/^'!//;s/'$//");
                            if [[ "$excluded" == false ]]; then
                                filtered+=("$m");
                            fi;
                        done;
                        matches=("${filtered[@]}");
                    fi;
                    if [[ ${#matches[@]} -gt 0 ]]; then
                        cmd="${cmd% *} ${matches[*]}";
                    fi;
                fi;
            fi;
        fi;
    """.replace("\n", " ").strip()

    # Mode-aware reload: prepend pinned opts if in pinned mode
    # Reads state from RGI_STATE_FILE since $FZF_HEADER isn't available in transform
    # Debounce with sleep 0.1 to reduce intermediate ripgrep processes while typing
    reload_transform = f"""
        sleep 0.01;
        state_file="$RGI_STATE_FILE";
        pinned_opts="";
        if [[ -f "$state_file" ]]; then
            state=$(cat "$state_file");
            mode="${{state%%|*}}";
            if [[ "$mode" == "pinned" ]]; then
                pinned_opts="${{state#*|}}";
            fi;
        fi;
        cmd="$FZF_QUERY";
        {glob_expand}
        if [[ "$cmd" =~ ^rg ]]; then
            cmd="${{cmd#rg}}";
            if [[ -n "$pinned_opts" ]]; then
                cmd="rg $pinned_opts {implicit_opts}$cmd";
            else
                cmd="rg {implicit_opts}$cmd";
            fi;
        fi;
        printf 'reload:RIPGREP_CONFIG_PATH= eval %q 2>/dev/null | {delta}' "$cmd"
    """.replace("\n", " ").strip()

    # For start event, we use direct reload since we know the initial state
    if config_args:
        # Pinned mode: prepend config_args
        # Define pinned_opts so glob_expand can filter against exclusion patterns
        start_reload = f"""
            pinned_opts="{config_args}";
            cmd={{q}};
            {glob_expand}
            if [[ "$cmd" =~ ^rg ]]; then
                cmd="${{cmd#rg}}";
                cmd="rg {config_args} {implicit_opts}$cmd";
            fi;
            RIPGREP_CONFIG_PATH= eval "$cmd" 2>/dev/null | {delta}
        """.replace("\n", " ").strip()
    else:
        # Inline mode: no prepending
        # No pinned_opts, so glob_expand won't filter
        start_reload = f"""
            pinned_opts="";
            cmd={{q}};
            {glob_expand}
            if [[ "$cmd" =~ ^rg ]]; then
                cmd="${{cmd#rg}}";
                cmd="rg {implicit_opts}$cmd";
            fi;
            RIPGREP_CONFIG_PATH= eval "$cmd" 2>/dev/null | {delta}
        """.replace("\n", " ").strip()

    # Toggle between inline and pinned modes using helper script
    toggle_pinned = "rgi-toggle-pinned"

    # Tab completion for paths (like shell readline/zle)
    # - Single match: complete fully, add / for directories
    # - Multiple matches: complete to longest common prefix
    # - No matches or option flag: no change
    tab_complete = """
        q="$FZF_QUERY";
        last="${q##* }";
        [[ "$last" == -* || -z "$last" ]] && { echo "$q"; exit; };
        IFS=$'\\n' read -d '' -ra matches < <(compgen -f -- "$last" 2>/dev/null; printf '\\0');
        if [[ ${#matches[@]} -eq 1 ]]; then
            m="${matches[0]}";
            [[ -d "$m" ]] && m="$m/";
            echo "${q% *} $m";
        elif [[ ${#matches[@]} -gt 1 ]]; then
            pfx="${matches[0]}";
            for m in "${matches[@]}"; do
                while [[ "${m:0:${#pfx}}" != "$pfx" && -n "$pfx" ]]; do
                    pfx="${pfx:0:-1}";
                done;
            done;
            [[ "$pfx" != "$last" ]] && echo "${q% *} $pfx" || echo "$q";
        else
            echo "$q";
        fi
    """.replace("\n", " ").strip()

    # Save to history before opening editor (fzf's --history only saves on exit, but rgi persists)
    history_file = str(HISTORY_FILE)
    save_history = (
        f'[[ "$(tail -1 {history_file} 2>/dev/null)" != {{q}} ]] && echo {{q}} >> {history_file};'
    )
    enter_execute = f"{save_history} open-in-editor {{1}} {{2}}"

    cmd = fzf_base() + [
        "-d:",
        "--query",
        full_command,
        "--disabled",
        "--footer",
        initial_footer,
        "--preview",
        "[[ -n {1} ]] && rgi-preview {1} {2}",
        "--history",
        str(HISTORY_FILE),
        "--bind",
        f"start:reload:{start_reload}",
        # When using default path '.', position cursor before it so user can type pattern
        # Use result event (fires after filtering) and unbind to run only once
        "--bind",
        "result:backward-char+backward-char+unbind(result)"
        if not pattern and not paths and not rg_opts
        else "result:ignore",
        "--bind",
        f"change:transform:{reload_transform}",
        "--bind",
        f"enter:execute:{enter_execute}",
        "--bind",
        "alt-up:prev-history",
        "--bind",
        "alt-down:next-history",
        "--bind",
        "ctrl-p:up",
        "--bind",
        "ctrl-n:down",
        # Toggle between inline (all opts in query) and pinned (opts in footer) modes
        "--bind",
        rf"ctrl-\:transform:{toggle_pinned}",
        # Tab completion for paths (like shell readline)
        "--bind",
        f"tab:transform-query:{tab_complete}",
    ]

    return cmd


if __name__ == "__main__":
    main()
