#!/bin/bash

# Debug logging (disabled for now)
# echo "rgi started with args: $@" >> /tmp/rgi-debug.log

# Get absolute path to this script
SCRIPT_PATH="$(realpath "${BASH_SOURCE[0]}" 2>/dev/null || readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")"
if [[ ! "$SCRIPT_PATH" = /* ]]; then
    SCRIPT_PATH="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
fi

# Get directory containing this script
SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"

# Add script directory to PATH so rgi-preview can be found
export PATH="$SCRIPT_DIR:$PATH"

# Parse arguments
pattern=""
paths=()
rg_opts=""
MODE="command"

# Single pass through arguments
while [[ $# -gt 0 ]]; do
    if [[ "$1" == "--rgi-command-mode" ]]; then
        MODE="command"
        shift
    elif [[ "$1" == "--rgi-pattern-mode" ]]; then
        MODE="pattern"
        shift
    elif [[ "$1" =~ ^- ]]; then
        opt="$1"
        rg_opts+=" $opt"
        shift
        case "$opt" in
            -g|--glob|-t|--type|-e|--regexp)
                [[ $# -gt 0 ]] && rg_opts+=" '$1'" && shift
                ;;
        esac
    else
        break
    fi
done

# Pattern and paths
[[ $# -gt 0 ]] && pattern="$1" && shift
while [[ $# -gt 0 ]]; do paths+=("$1"); shift; done
[[ ${#paths[@]} -eq 0 ]] && paths=(.)

# Implicit options that are always applied but never shown
IMPLICIT_OPTS="--json"

# Commands  
RG="rg$rg_opts $IMPLICIT_OPTS"
DELTA="delta --grep-output-type classic"

# fzf wrapper
fzf() {
    command fzf \
        --layout reverse \
        --info hidden \
        --prompt ' ' \
        --color light \
        --ansi \
        --bind ctrl-k:kill-line \
        --bind alt-right:forward-word \
        --bind alt-left:backward-word \
        --preview-window up,70% \
        "$@"
}

# Use --phony with start:reload to show initial results
# Hack: to trigger display we append a space and then delete it on start
if [[ "$MODE" == "command" ]]; then
    # Command mode - show the full rg command (except --json)
    full_command="rg$rg_opts $pattern ${paths[*]}"

    echo "" |
    fzf -d: \
        --query="$full_command " \
        --phony \
        --bind='start:reload:cmd={q}; if [[ "$cmd" =~ ^rg ]]; then cmd="${cmd#rg}"; cmd="rg '"$IMPLICIT_OPTS"'$cmd"; fi; eval "$cmd" 2>/dev/null | '"$DELTA" \
        --bind='start:backward-delete-char' \
        --bind='change:reload:cmd={q}; if [[ "$cmd" =~ ^rg ]]; then cmd="${cmd#rg}"; cmd="rg '"$IMPLICIT_OPTS"'$cmd"; fi; eval "$cmd" 2>/dev/null | '"$DELTA" \
        --bind='tab:execute:rgi-switch-mode pattern {q} '"$rg_opts"' '"${paths[*]}"' ' \
        --bind='enter:execute:open-in-editor {1} {2}' \
        --preview="[[ -n {1} ]] && rgi-preview {1} {2}"
elif [[ "$MODE" == "pattern" ]]; then
    # Pattern mode - the query is just the search pattern
    echo "" |
    fzf -d: \
        --query="$pattern " \
        --phony \
        --bind='start:reload:'"$RG"' "'"$pattern"'" '"${paths[*]}"' 2>/dev/null | '"$DELTA" \
        --bind='start:backward-delete-char' \
        --bind='change:reload:'"$RG"' {q} '"${paths[*]}"' 2>/dev/null | '"$DELTA" \
        --bind='tab:execute:rgi-switch-mode command {q} '"$rg_opts"' '"${paths[*]}"' ' \
        --bind='enter:execute:open-in-editor {1} {2}' \
        --header='rg'"$rg_opts"' {q} '"${paths[*]}" \
        --preview="[[ -n {1} ]] && rgi-preview {1} {2}"
fi
